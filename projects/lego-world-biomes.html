<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LEGO World: Biomes Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            margin: 0; background-color: #050510; overflow: hidden;
            font-family: 'Press Start 2P', cursive; user-select: none; color: white;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* FX LAYERS */
        .vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(0,0,0,0.6) 100%);
            pointer-events: none; z-index: 5;
        }
        #flash-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white; opacity: 0; pointer-events: none; z-index: 20; transition: opacity 0.1s;
        }
        #save-msg, #mode-msg {
            position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); color: #0f0; padding: 15px; border: 2px solid #0f0;
            display: none; z-index: 100; text-align: center; font-size: 0.7rem; box-shadow: 0 0 10px #0f0;
        }

        /* SIDEBAR */
        #sidebar {
            position: absolute; top: 0; right: 0; bottom: 0; width: 360px;
            background: rgba(10, 15, 30, 0.95); border-left: 4px solid #445;
            transform: translateX(0); transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            pointer-events: auto; padding: 25px; box-sizing: border-box;
            display: flex; flex-direction: column; gap: 20px;
            z-index: 50; overflow-y: auto;
            box-shadow: -10px 0 30px rgba(0,0,0,0.8);
        }
        #sidebar.closed { transform: translateX(100%); }

        .sidebar-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid #555; padding-bottom: 15px; }
        .sidebar-toggle {
            pointer-events: auto; cursor: pointer;
            background: #222; border: 2px solid #666; color: #fff;
            padding: 8px 12px; font-size: 0.7rem; transition: all 0.2s;
        }
        .sidebar-toggle:hover { background: #fff; color: #000; border-color: #fff; }

        .btn-group { display: flex; gap: 10px; }
        .btn {
            flex: 1; padding: 10px; font-family: inherit; font-size: 0.6rem;
            cursor: pointer; background: #333; color: white; border: 2px solid #555;
        }
        .btn:hover { background: #555; border-color: #fff; }

        h2 { color: #ffcc00; font-size: 1rem; margin: 0; text-shadow: 2px 2px 0 #000; }
        h3 { color: #fff; font-size: 0.7rem; margin: 0 0 10px 0; text-decoration: underline; text-decoration-color: #555; }
        p { font-size: 0.6rem; line-height: 1.8; color: #aaa; margin: 0; }
        .key { color: #00f3ff; background: rgba(0, 243, 255, 0.1); padding: 2px 4px; border-radius: 4px; }

        /* TOOL GRID IN MENU */
        .tool-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
        .tool-item { display: flex; align-items: center; gap: 10px; font-size: 0.6rem; color: #ccc; }

        /* UI LAYOUT */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 30;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .top-bar {
            padding: 25px; display: flex; justify-content: space-between; align-items: flex-start;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }

        /* BOTTOM HUD */
        .hud-bottom {
            display: flex; flex-direction: column; align-items: center; padding-bottom: 30px;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
        }

        #tool-label {
            margin-bottom: 10px; color: #ffcc00; font-size: 0.8rem; text-shadow: 2px 2px 0 #000;
            background: rgba(0,0,0,0.6); padding: 5px 10px; border-radius: 4px; border: 1px solid #555;
        }

        .hotbar-container {
            pointer-events: auto; display: flex; gap: 8px;
            background: rgba(10, 10, 10, 0.8); padding: 10px; border-radius: 12px;
            backdrop-filter: blur(5px); border: 2px solid #444;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }

        .slot {
            width: 48px; height: 48px; background: rgba(40, 40, 40, 0.8);
            border: 2px solid #666; display: flex; justify-content: center; align-items: center;
            cursor: pointer; transition: all 0.1s; position: relative;
        }
        .slot:hover { border-color: #aaa; transform: translateY(-2px); }
        .slot.active { border-color: #ffcc00; background: rgba(255, 204, 0, 0.15); transform: scale(1.1) translateY(-5px); z-index: 10; box-shadow: 0 0 15px rgba(255, 204, 0, 0.4); }
        .slot-key { position: absolute; top: 2px; left: 4px; font-size: 0.5rem; color: #fff; text-shadow: 1px 1px 0 #000; opacity: 0.8; }

        /* ICONS - FIXED SIZING */
        .icon { width: 32px; height: 32px; display: block; box-shadow: 2px 2px 0 rgba(0,0,0,0.5); }
        .tiny-icon { width: 16px; height: 16px; display: block; box-shadow: 1px 1px 0 rgba(0,0,0,0.5); border: 1px solid #555; }

        .i-grass { background: #44aa44; border-top: 4px solid #66cc66; }
        .i-stone { background: #888; border-bottom: 4px solid #555; }
        .i-water { background: #44aaff; opacity: 0.9; }
        .i-lava { background: #ff4400; box-shadow: 0 0 5px #ff4400; }
        .i-wood { background: #5D4037; border: 1px solid #3E2723; }
        .i-glass { background: linear-gradient(135deg, rgba(200,240,255,0.6), rgba(255,255,255,0.8)); border: 1px solid #fff; }
        .i-glow { background: #ffffaa; box-shadow: 0 0 8px #ffff00; }
        .i-char { background: #ffcc00; border-radius: 50%; border: 2px solid #000; }
        .i-pet { background: #d2691e; border-radius: 4px; border: 2px solid #fff; }
        .i-tnt { background: repeating-linear-gradient(45deg, #cc0000, #cc0000 5px, #fff 5px, #fff 10px); border: 1px solid #000; }

        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            color: white; cursor: pointer; pointer-events: auto;
            backdrop-filter: blur(10px); transition: opacity 0.5s;
        }
        .blink { animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0; } }

        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 20; opacity: 0.8;
        }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: white; box-shadow: 0 0 4px #000; }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }

        /* Back Button */
        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 12px 24px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #666;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.6rem;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 1000;
            pointer-events: auto;
            text-decoration: none;
            display: inline-block;
        }
        .back-button:hover {
            background: #fff;
            color: #000;
            border-color: #fff;
            transform: translateY(-2px);
        }

    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <a href="index.html" class="back-button">← BACK TO MAIN</a>

    <div id="start-overlay" onclick="initApp()">
        <h1 style="color:#ffcc00; margin-bottom: 20px; font-size: 2.5rem; text-shadow: 0 0 20px #ffcc00;">LEGO WORLD</h1>
        <div style="font-size: 0.8rem; color: #fff; margin-bottom: 40px; letter-spacing: 2px;">BIOMES EDITION</div>
        <div class="blink" style="background:#222; padding:15px; border: 2px solid #fff;">[ CLICK TO ENTER ]</div>
    </div>

    <div id="save-msg">GAME SAVED!</div>
    <div id="mode-msg">DRONE MODE ACTIVE<br><span style="font-size:0.6rem; color:#ccc;">WASD = Move | SPACE/SHIFT = Up/Down</span></div>

    <div id="flash-overlay"></div>
    <div class="vignette"></div>
    <div id="crosshair"></div>

    <!-- Sidebar -->
    <div id="sidebar">
        <div class="sidebar-header">
            <h2>SYSTEM</h2>
            <div class="sidebar-toggle" onclick="toggleSidebar()">CLOSE &gt;</div>
        </div>

        <div>
            <h3>TOOL GUIDE</h3>
            <div class="tool-grid">
                <div class="tool-item"><div class="tiny-icon i-grass"></div> 1: Grass</div>
                <div class="tool-item"><div class="tiny-icon i-stone"></div> 2: Stone</div>
                <div class="tool-item"><div class="tiny-icon i-water"></div> 3: Water</div>
                <div class="tool-item"><div class="tiny-icon i-lava"></div> 4: Lava</div>
                <div class="tool-item"><div class="tiny-icon i-wood"></div> 5: Wood</div>
                <div class="tool-item"><div class="tiny-icon i-char"></div> 6: Citizen</div>
                <div class="tool-item"><div class="tiny-icon i-pet"></div> 7: Pet</div>
                <div class="tool-item"><div class="tiny-icon i-tnt"></div> 8: TNT</div>
                <div class="tool-item"><div class="tiny-icon i-glow"></div> 9: Glow</div>
                <div class="tool-item"><div class="tiny-icon i-glass"></div> 0: Glass</div>
            </div>
        </div>

        <hr style="border-color:#333; width:100%;">

        <div>
            <h3>CONTROLS</h3>
            <p><span class="key">WASD</span> Move (Drone)</p>
            <p><span class="key">C</span> Switch Camera</p>
            <p><span class="key">T</span> Toggle Rain</p>
            <p><span class="key">F</span> Flashlight</p>
            <p><span class="key">M-CLICK</span> Pick Block</p>
        </div>

        <div>
            <h3>WORLD</h3>
            <div class="btn-group">
                <button class="btn" onclick="saveWorld()">SAVE</button>
                <button class="btn" onclick="loadWorld()">LOAD</button>
            </div>
            <p style="margin-top:5px;">Seed: <span id="seed-val" style="color:#fff;">...</span></p>
        </div>
    </div>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div class="top-bar">
            <div>
                <h1 style="margin:0; color: #fff; font-size: 1.2rem; text-shadow: 0 0 10px #0ff;">VOXEL ENGINE</h1>
                <div style="font-size: 0.6rem; color: #0f0; margin-top: 5px;" id="audio-status">SYSTEM READY</div>
            </div>
            <div style="display:flex; gap: 15px; align-items:center;">
                <div id="time-display" style="text-shadow: 0 0 5px #ffcc00;">12:00 PM</div>
                <div class="sidebar-toggle" onclick="toggleSidebar()">⚙ MENU</div>
            </div>
        </div>

        <div class="hud-bottom">
            <div id="tool-label">SELECTED: GRASS BLOCK</div>
            <div class="hotbar-container">
                <div class="slot active" onclick="selectSlot(0)" title="Grass"><span class="slot-key">1</span><div class="icon i-grass"></div></div>
                <div class="slot" onclick="selectSlot(1)" title="Stone"><span class="slot-key">2</span><div class="icon i-stone"></div></div>
                <div class="slot" onclick="selectSlot(2)" title="Water"><span class="slot-key">3</span><div class="icon i-water"></div></div>
                <div class="slot" onclick="selectSlot(3)" title="Lava"><span class="slot-key">4</span><div class="icon i-lava"></div></div>
                <div class="slot" onclick="selectSlot(4)" title="Wood"><span class="slot-key">5</span><div class="icon i-wood"></div></div>
                <div class="slot" onclick="selectSlot(5)" title="Citizen"><span class="slot-key">6</span><div class="icon i-char"></div></div>
                <div class="slot" onclick="selectSlot(6)" title="Pet"><span class="slot-key">7</span><div class="icon i-pet"></div></div>
                <div class="slot" onclick="selectSlot(7)" title="TNT"><span class="slot-key">8</span><div class="icon i-tnt"></div></div>
                <div class="slot" onclick="selectSlot(8)" title="Glowstone"><span class="slot-key">9</span><div class="icon i-glow"></div></div>
                <div class="slot" onclick="selectSlot(9)" title="Glass"><span class="slot-key">0</span><div class="icon i-glass"></div></div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CORE ---
        let SEED = Math.floor(Math.random() * 999999);
        document.getElementById('seed-val').innerText = SEED;
        function mulberry32(a) {
            return function() {
              var t = a += 0x6D2B79F5;
              t = Math.imul(t ^ t >>> 15, t | 1);
              t ^= t + Math.imul(t ^ t >>> 7, t | 61);
              return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }
        let rand = mulberry32(SEED);

        // --- AUDIO ---
        const AudioSys = {
            ctx: null,
            init: function() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                if(this.ctx.state === 'suspended') this.ctx.resume();
                document.getElementById('audio-status').innerText = "AUDIO ONLINE";
            },
            play3D: function(freq, type, dur, pos, vol=0.1) {
                if(!this.ctx) return;
                const o = this.ctx.createOscillator(); o.type = type;
                const g = this.ctx.createGain();
                const panner = this.ctx.createPanner();
                panner.panningModel = 'HRTF'; panner.distanceModel = 'inverse'; panner.refDistance = 5; panner.maxDistance = 100;
                panner.positionX.value = pos.x; panner.positionY.value = pos.y; panner.positionZ.value = pos.z;
                o.frequency.setValueAtTime(freq, this.ctx.currentTime);
                g.gain.setValueAtTime(vol, this.ctx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime+dur);
                o.connect(g); g.connect(panner); panner.connect(this.ctx.destination);
                o.start(); o.stop(this.ctx.currentTime+dur);
            },
            tone: function(freq, type, dur, vol=0.1) {
                if(!this.ctx) return;
                const o = this.ctx.createOscillator(); o.type = type;
                const g = this.ctx.createGain();
                o.frequency.setValueAtTime(freq, this.ctx.currentTime);
                g.gain.setValueAtTime(vol, this.ctx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime+dur);
                o.connect(g); g.connect(this.ctx.destination);
                o.start(); o.stop(this.ctx.currentTime+dur);
            },
            noise: function(dur=0.5, pos) {
                if(!this.ctx) return;
                const b = this.ctx.createBuffer(1, this.ctx.sampleRate, this.ctx.sampleRate);
                const d = b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
                const s = this.ctx.createBufferSource(); s.buffer = b;
                const g = this.ctx.createGain(); g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime+dur);
                if(pos) {
                    const p = this.ctx.createPanner();
                    p.positionX.value = pos.x; p.positionY.value = pos.y; p.positionZ.value = pos.z;
                    s.connect(g); g.connect(p); p.connect(this.ctx.destination);
                } else { s.connect(g); g.connect(this.ctx.destination); }
                s.start();
            },
            fx: {
                break: () => AudioSys.tone(100, 'sawtooth', 0.1, 0.1),
                place: () => AudioSys.tone(400, 'square', 0.05, 0.05),
                explode: (pos) => AudioSys.noise(1.5, pos),
                fuse: () => AudioSys.tone(800, 'sine', 0.1, 0.02),
                step: () => AudioSys.tone(50, 'triangle', 0.05, 0.05),
                save: () => { AudioSys.tone(600,'sine',0.1); setTimeout(()=>AudioSys.tone(800,'sine',0.2),100); }
            }
        };

        // --- HANDLERS ---
        window.initApp = () => { AudioSys.init(); document.getElementById('start-overlay').style.opacity = 0; setTimeout(()=>document.getElementById('start-overlay').style.display='none', 500); };
        window.toggleSidebar = () => document.getElementById('sidebar').classList.toggle('closed');

        // --- SCENE ---
        const CONFIG = { pixelScale: 1.5 };
        const state = {
            tool: 0, time: 0.35, voxels: {}, liquids: [], clouds: [], entities: [], meteors: [], lights: [],
            flashOn: false, raining: false, mode: 'orbit'
        };
        const toolNames = ['GRASS BLOCK', 'STONE BLOCK', 'WATER SOURCE', 'LAVA SOURCE', 'WOOD BLOCK', 'CITIZEN', 'PET', 'TNT', 'GLOWSTONE', 'GLASS'];
        const keys = { w:false, a:false, s:false, d:false, space:false, shift:false };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 90);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(20, 30, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        const orbitCtrl = new OrbitControls(camera, renderer.domElement);
        orbitCtrl.enableDamping = true; orbitCtrl.dampingFactor = 0.05; orbitCtrl.maxDistance = 100;

        const fpsCtrl = new PointerLockControls(camera, document.body);
        const velocity = new THREE.Vector3();

        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2; bloomPass.strength = 0.8; bloomPass.radius = 0.5;
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene); composer.addPass(bloomPass);

        // --- LIGHTING ---
        const sunMesh = new THREE.Mesh(new THREE.BoxGeometry(6,6,6), new THREE.MeshBasicMaterial({color: 0xffffaa}));
        scene.add(sunMesh);
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        sunLight.castShadow = true; sunLight.shadow.mapSize.set(2048,2048);
        sunLight.shadow.camera.left = -60; sunLight.shadow.camera.right = 60;
        sunLight.shadow.camera.top = 60; sunLight.shadow.camera.bottom = -60;
        scene.add(sunLight);

        const moonMesh = new THREE.Mesh(new THREE.BoxGeometry(4,4,4), new THREE.MeshBasicMaterial({color: 0xcccccc}));
        scene.add(moonMesh);
        const moonLight = new THREE.DirectionalLight(0x444466, 0.3);
        scene.add(moonLight);

        const flashLight = new THREE.SpotLight(0xffffff, 0, 50, 0.5, 0.5, 1);
        flashLight.castShadow = true; scene.add(flashLight); scene.add(flashLight.target);
        const ambLight = new THREE.AmbientLight(0xffffff, 0.3); scene.add(ambLight);

        // --- RAIN ---
        const rainGeo = new THREE.BufferGeometry();
        const rainPos = new Float32Array(1500*3);
        for(let i=0; i<1500*3; i++) rainPos[i] = (Math.random()-0.5)*60;
        rainGeo.setAttribute('position', new THREE.BufferAttribute(rainPos, 3));
        const rainMat = new THREE.PointsMaterial({color:0xaaaaaa, size:0.2, transparent:true});
        const rainSystem = new THREE.Points(rainGeo, rainMat);
        rainSystem.visible = false; scene.add(rainSystem);

        // --- MATERIALS ---
        const geoBox = new THREE.BoxGeometry(1, 1, 1);
        const matCache = {};
        function getMat(color, type='solid') {
            const k = color + type;
            if(!matCache[k]) {
                let props = { color, roughness: 0.7, metalness: 0.1, flatShading: true };
                if(type === 'liquid') { props.transparent=true; props.opacity=0.75; props.roughness=0.0; props.metalness=0.2; }
                else if(type === 'glow') { props.emissive = color; props.emissiveIntensity = 2.0; }
                else if(type === 'glass') { props.transparent=true; props.opacity=0.3; props.roughness=0.0; }
                else if(type === 'cloud') { props.transparent=true; props.opacity=0.85; }
                else if(type === 'snow') { props.roughness = 1.0; props.color = 0xffffff; }
                matCache[k] = new THREE.MeshStandardMaterial(props);
            }
            return matCache[k];
        }

        // --- VOXELS ---
        function addVoxel(x, y, z, type) {
            const k = `${x},${y},${z}`; if(state.voxels[k]) return;
            let col=0x888888, matType='solid';

            if(type==='grass') col=0x44aa44;
            else if(type==='dirt') col=0x8B4513;
            else if(type==='stone') col=0x777777;
            else if(type==='water'){col=0x44aaff; matType='liquid';}
            else if(type==='lava'){col=0xff4400; matType='glow';}
            else if(type==='wood'){col=0x5D4037;}
            else if(type==='leaves'){col=0x228822;}
            else if(type==='cloud'){col=0xffffff; matType='cloud';}
            else if(type==='glow'){col=0xffffaa; matType='glow';}
            else if(type==='glass'){col=0xffffff; matType='glass';}
            else if(type==='sand'){col=0xE6C288;}
            else if(type==='snow'){col=0xffffff; matType='snow';}

            const grp = new THREE.Group(); grp.position.set(x,y,z);
            const box = new THREE.Mesh(geoBox, getMat(col, matType));
            box.castShadow = (matType!=='liquid' && matType!=='glass'); box.receiveShadow = true;
            box.userData = { parent: grp, type, x, y, z, isVoxel: true };
            grp.add(box);

            if(matType==='liquid') {
                box.scale.set(0.95, 0.8, 0.95); box.position.y = -0.1;
                state.liquids.push({ mesh: box, yBase: -0.1, offset: Math.random()*10 });
            } else if(matType==='cloud') state.clouds.push(grp);

            if(type === 'glow' || type === 'lava') {
                const light = new THREE.PointLight(col, 2, 8); light.position.y = 0;
                grp.add(light); state.lights.push(light);
            }

            if(type === 'tnt') {
                 box.material = getMat(0xcc0000, 'solid');
                 const s = new THREE.Mesh(new THREE.BoxGeometry(1.02, 0.2, 1.02), getMat(0xffffff)); grp.add(s);
                 box.userData.type = 'tnt';
            }

            scene.add(grp); state.voxels[k] = grp;
            return grp;
        }

        // --- ENTITIES ---
        class Entity {
            constructor(grp, type, head) {
                this.grp = grp; this.type = type; this.head = head;
                this.state = 'IDLE'; this.timer = Math.random();
                this.targetPos = grp.position.clone();
            }
            update(dt) {
                if(this.head && this.grp.position.distanceTo(camera.position)<20) {
                    const m = new THREE.Matrix4().lookAt(camera.position, this.grp.position, new THREE.Vector3(0,1,0));
                    this.head.quaternion.slerp(new THREE.Quaternion().setFromRotationMatrix(m), 0.1);
                }
                if(this.type === 'TNT') return;
                if(this.state === 'IDLE') {
                    const cx=Math.round(this.grp.position.x), cy=Math.round(this.grp.position.y), cz=Math.round(this.grp.position.z);
                    if(!state.voxels[`${cx},${cy-1},${cz}`]) { this.targetPos.set(cx, cy-1, cz); this.state='MOVING'; }
                    else { this.timer-=dt; if(this.timer<=0) this.pickTarget(); }
                } else if(this.state === 'MOVING') {
                    const dir = new THREE.Vector3().subVectors(this.targetPos, this.grp.position);
                    const speed = 4.0 * dt;
                    if(dir.length()<speed) {
                        this.grp.position.copy(this.targetPos); this.state='IDLE'; this.timer=1+Math.random()*2;
                        if(this.targetPos.y < this.grp.position.y) AudioSys.play3D(100, 'triangle', 0.1, this.grp.position, 0.05);
                    } else {
                        dir.normalize(); this.grp.position.add(dir.multiplyScalar(speed));
                        const lookTgt = this.targetPos.clone(); lookTgt.y=this.grp.position.y; this.grp.lookAt(lookTgt);
                        if(this.targetPos.y >= this.grp.position.y) this.grp.children[0].position.y = Math.sin(Date.now()*0.02)*0.3;
                    }
                }
            }
            pickTarget() {
                const dirs = [[0,1],[0,-1],[1,0],[-1,0]]; const d = dirs[Math.floor(Math.random()*4)];
                const tx=Math.round(this.grp.position.x+d[0]), tz=Math.round(this.grp.position.z+d[1]), ty=Math.round(this.grp.position.y);
                if(!state.voxels[`${tx},${ty},${tz}`]) {
                    if(state.voxels[`${tx},${ty-1},${tz}`]) { this.targetPos.set(tx,ty,tz); this.state='MOVING'; }
                } else if(!state.voxels[`${tx},${ty+1},${tz}`]) { this.targetPos.set(tx,ty+1,tz); this.state='MOVING'; }
            }
        }

        function createEntity(x, y, z, type) {
            const grp = new THREE.Group(); grp.position.set(x,y,z);
            const visuals = new THREE.Group(); grp.add(visuals);
            let headMesh;

            if(type === 'CHAR') {
                const col = [0xff0000, 0x2255ff, 0x22aa22][Math.floor(Math.random()*3)];
                const legs = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.3), getMat(0x222222)); legs.position.y=0.2; legs.castShadow=true;
                const torso = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.3), getMat(col)); torso.position.y=0.6; torso.castShadow=true;
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), getMat(0xffcc00)); head.position.y=0.95; head.castShadow=true;
                visuals.add(legs, torso, head); headMesh=head;
            } else {
                const mat = getMat(type==='CAT'?0xffaa00:0x8B4513);
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.8), mat); body.position.y=0.5; body.castShadow=true;
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), mat); head.position.set(0,1,0.5); head.castShadow=true;
                visuals.add(body, head); headMesh=head;
            }
            const hit = new THREE.Mesh(new THREE.BoxGeometry(0.8,1.5,0.8), new THREE.MeshBasicMaterial({visible:false}));
            hit.position.y=0.75; hit.userData={parent:grp, isEntity:true}; grp.add(hit);

            scene.add(grp);
            const ent = new Entity(grp, type, headMesh);
            hit.userData.ref = ent; state.entities.push(ent);
            spawnParticles(grp.position, 0xffffff, 10);
            AudioSys.play3D(300, 'sine', 0.2, grp.position, 0.1);
        }

        function createTree(x, y, z) {
            let h = 3 + Math.floor(rand()*3);
            for(let i=0; i<h; i++) addVoxel(x, y+i, z, 'wood');
            for(let lx=x-2; lx<=x+2; lx++) for(let ly=y+h-2; ly<=y+h+1; ly++) for(let lz=z-2; lz<=z+2; lz++) {
                if(Math.abs(lx-x)+Math.abs(ly-(y+h))+Math.abs(lz-z) <= 3 && !state.voxels[`${lx},${ly},${lz}`]) addVoxel(lx, ly, lz, 'leaves');
            }
        }

        // --- BIOME GENERATION ---
        function generateWorld() {
            for(let x=-10;x<=10;x++) for(let z=-10;z<=10;z++) {
                let h = Math.floor(Math.sin(x*0.25 + rand())*3 + Math.cos(z*0.25 + rand())*3);

                // BIOME LOGIC
                for(let y=-3;y<=h;y++) {
                    let type = 'stone';
                    if(y === h) {
                        if(y >= 5) type = 'snow'; // Snow Peak
                        else if(y <= 0) type = 'sand'; // Beach
                        else type = 'grass';
                    } else {
                        if(y > h-2 && y < 5 && y > 0) type = 'dirt';
                    }
                    addVoxel(x, y, z, type);
                }

                // Water
                if(h < 0) for(let y=h+1;y<=-1;y++) addVoxel(x, y, z, 'water');

                // Trees (Only on grass)
                if(h > 0 && h < 5 && rand() > 0.92) createTree(x, h+1, z);
            }
            // Clouds
            for(let i=0; i<15; i++) {
                const cx = Math.floor((rand()-0.5)*40); const cz = Math.floor((rand()-0.5)*40); const cy = 12 + Math.floor(rand()*4);
                addVoxel(cx, cy, cz, 'cloud'); addVoxel(cx+1, cy, cz, 'cloud');
            }
        }
        generateWorld();

        // --- FX PARTICLES ---
        const particles = []; const partGeo = new THREE.BoxGeometry(0.15,0.15,0.15);
        function spawnParticles(pos, col, count=6) {
            const mat = getMat(col);
            for(let i=0;i<count;i++) {
                const m = new THREE.Mesh(partGeo, mat);
                m.position.copy(pos).addScalar((Math.random()-0.5)*0.5); scene.add(m);
                particles.push({mesh:m, vel: new THREE.Vector3((Math.random()-0.5)*0.3, Math.random()*0.4, (Math.random()-0.5)*0.3), life: 100});
            }
        }

        // --- SAVE/LOAD ---
        window.saveWorld = () => {
            const data = [];
            for(let k in state.voxels) {
                const v = state.voxels[k].children[0].userData;
                data.push({x:v.x, y:v.y, z:v.z, t:v.type});
            }
            localStorage.setItem('lego-world-bio', JSON.stringify({seed: SEED, voxels: data}));
            const msg = document.getElementById('save-msg'); msg.style.display='block'; setTimeout(()=>msg.style.display='none', 2000);
            AudioSys.fx.save();
        };

        window.loadWorld = () => {
            const raw = localStorage.getItem('lego-world-bio'); if(!raw) return;
            for(let k in state.voxels) scene.remove(state.voxels[k]);
            state.voxels = {}; state.liquids=[]; state.clouds=[]; state.entities.forEach(e=>scene.remove(e.grp)); state.entities=[];
            const data = JSON.parse(raw);
            SEED = data.seed; rand = mulberry32(SEED);
            data.voxels.forEach(v => addVoxel(v.x, v.y, v.z, v.t));
            AudioSys.fx.place();
        };

        // --- INPUT ---
        const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2();
        const hlMesh = new THREE.Mesh(new THREE.BoxGeometry(1.05,1.05,1.05), new THREE.MeshBasicMaterial({color:0xffffff, wireframe:true, opacity:0.5, transparent:true}));
        scene.add(hlMesh);

        window.addEventListener('keydown',e=>{
            if(e.key>'0'&&e.key<='9') selectSlot(parseInt(e.key)-1);
            if(e.key==='0') selectSlot(9);
            if(e.key.toLowerCase()==='f') { state.flashOn=!state.flashOn; AudioSys.fx.place(); }
            if(e.key.toLowerCase()==='t') {
                state.raining=!state.raining; rainSystem.visible=state.raining;
            }
            if(e.key.toLowerCase()==='r' && state.mode==='orbit') orbitCtrl.reset();

            if(e.code==='KeyW') keys.w=true; if(e.code==='KeyA') keys.a=true;
            if(e.code==='KeyS') keys.s=true; if(e.code==='KeyD') keys.d=true;
            if(e.code==='Space') keys.space=true; if(e.code==='ShiftLeft') keys.shift=true;

            if(e.key.toLowerCase()==='c') {
                if(state.mode === 'orbit') {
                    state.mode = 'drone'; orbitCtrl.enabled = false; fpsCtrl.lock(); document.getElementById('mode-msg').style.display='block';
                } else {
                    state.mode = 'orbit'; orbitCtrl.enabled = true; fpsCtrl.unlock(); document.getElementById('mode-msg').style.display='none';
                }
            }
        });
        window.addEventListener('keyup',e=>{
            if(e.code==='KeyW') keys.w=false; if(e.code==='KeyA') keys.a=false;
            if(e.code==='KeyS') keys.s=false; if(e.code==='KeyD') keys.d=false;
            if(e.code==='Space') keys.space=false; if(e.code==='ShiftLeft') keys.shift=false;
        });

        window.selectSlot = (i) => {
            state.tool = i;
            document.querySelectorAll('.slot').forEach((s,idx)=>s.classList.toggle('active',idx===i));
            document.getElementById('tool-label').innerText = "SELECTED: " + toolNames[i];
        };

        window.addEventListener('mousedown',e=>{
            if(state.mode === 'drone' && !fpsCtrl.isLocked) { fpsCtrl.lock(); return; }
            if(e.target.closest('.hotbar-container') || e.target.closest('#sidebar') || e.target.closest('.back-button')) return;

            raycaster.setFromCamera(state.mode==='drone'?new THREE.Vector2(0,0):mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            const hit = intersects.find(i => i.object.userData.parent);

            if(hit) {
                const grp = hit.object.userData.parent;
                const type = hit.object.userData.type;

                if(e.button===1) { // Pick
                    e.preventDefault();
                    const map = {'grass':0, 'stone':1, 'water':2, 'lava':3, 'wood':4, 'leaves':4, 'glow':8, 'glass':9};
                    if(map[type] !== undefined) selectSlot(map[type]);
                    return;
                }

                if(state.tool===7 && e.button===0) {
                    state.meteors.push({pos:grp.position.clone().add(new THREE.Vector3(5,20,5)), target:grp.position.clone(), mesh:new THREE.Mesh(new THREE.DodecahedronGeometry(1.5), getMat(0x330000, 'glow'))});
                    scene.add(state.meteors[state.meteors.length-1].mesh); return;
                }

                if(e.button===0) { // Break
                    if(type==='tnt') { grp.userData.ignited=true; grp.userData.timer=60; AudioSys.fx.fuse(); }
                    else {
                        scene.remove(grp); delete state.voxels[`${grp.position.x},${grp.position.y},${grp.position.z}`];
                        AudioSys.fx.break(); spawnParticles(grp.position, hit.object.material.color);
                    }
                } else if(e.button===2) { // Place
                    const pos = grp.position.clone().add(hit.face.normal);
                    const tools = ['grass','stone','water','lava','wood','char','pet','tnt','glow','glass'];
                    const t = tools[state.tool];
                    if(t) {
                        AudioSys.fx.place();
                        if(t==='pet') createEntity(pos.x, pos.y, pos.z, rand()>0.5?'CAT':'DOG');
                        else if(t==='char') createEntity(pos.x, pos.y, pos.z, 'CHAR');
                        else addVoxel(pos.x, pos.y, pos.z, t);
                    }
                }
            }
        });
        window.addEventListener('mousemove',e=>{mouse.x=(e.clientX/window.innerWidth)*2-1;mouse.y=-(e.clientY/window.innerHeight)*2+1;});

        // --- FX HELPERS ---
        let shake=0; function shakeCamera(amt){shake=amt;}
        function flashScreen(){const f=document.getElementById('flash-overlay');f.style.opacity=1;setTimeout(()=>f.style.opacity=0,100);}

        // --- LOOP ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            // FPS Move
            if(state.mode === 'drone' && fpsCtrl.isLocked) {
                const speed = 15.0 * dt;
                velocity.set(0,0,0);
                if(keys.w) velocity.z = speed; if(keys.s) velocity.z = -speed;
                if(keys.a) velocity.x = -speed; if(keys.d) velocity.x = speed;
                if(keys.space) velocity.y = speed; if(keys.shift) velocity.y = -speed;
                fpsCtrl.moveRight(velocity.x); fpsCtrl.moveForward(velocity.z); camera.position.y += velocity.y;
            }

            // Time/Sky
            state.time += 0.0003; if(state.time>1) state.time=0;
            const t = state.time;
            const angle = (t-0.5)*Math.PI*2;
            sunMesh.position.set(Math.sin(angle)*60, Math.cos(angle)*60, 10); sunLight.position.copy(sunMesh.position);
            moonMesh.position.set(Math.sin(angle+Math.PI)*60, Math.cos(angle+Math.PI)*60, 10); moonLight.position.copy(moonMesh.position);

            let skyHex = state.raining ? 0x222233 : ((t>0.25&&t<0.75) ? 0x87CEEB : 0x050510);
            if(!state.raining && t>0.2 && t<0.3) skyHex = 0xffaa55;
            if(!state.raining && t>0.7 && t<0.8) skyHex = 0xff8844;
            scene.background.lerp(new THREE.Color(skyHex), 0.05);

            // Fog blend
            const fogCol = new THREE.Color(skyHex);
            if(state.raining) fogCol.lerp(new THREE.Color(0x111111), 0.5);
            scene.fog.color.lerp(fogCol, 0.05);

            sunLight.intensity = (t>0.25&&t<0.75)?(state.raining?0.5:1.5):0;
            moonLight.intensity = (t<0.25||t>0.75)?0.3:0;
            sunMesh.material.emissiveIntensity = (t>0.25&&t<0.75)?5:0;
            state.lights.forEach(l => l.intensity = 2 + Math.sin(Date.now()*0.005)*0.5);

            flashLight.intensity = state.flashOn ? 1.5 : 0;
            if(state.flashOn) {
                flashLight.position.copy(camera.position);
                const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
                flashLight.target.position.copy(camera.position).add(dir);
            }

            if(state.raining) {
                const positions = rainSystem.geometry.attributes.position.array;
                for(let i=1; i<positions.length; i+=3) {
                    positions[i] -= 0.5; if(positions[i] < -10) positions[i] = 40;
                }
                rainSystem.geometry.attributes.position.needsUpdate = true;
                rainSystem.position.copy(camera.position); rainSystem.position.y = 0;
                if(Math.random()<0.01) AudioSys.noise(0.5);
            }

            state.clouds.forEach(c => { c.position.x += 0.005; if(c.position.x>40) c.position.x=-40; });
            state.liquids.forEach(l => l.mesh.position.y = l.yBase + Math.sin(Date.now()*0.003 + l.offset)*0.05);

            raycaster.setFromCamera(state.mode==='drone'?new THREE.Vector2(0,0):mouse, camera);
            const hits = raycaster.intersectObjects(scene.children, true);
            const valid = hits.find(i=>i.object.userData.parent);
            if(valid && valid.distance < 20) {
                hlMesh.position.copy(valid.object.userData.parent.position); hlMesh.visible=true;
            } else hlMesh.visible=false;

            state.entities.forEach(en => en.update(dt));

            // TNT
            for(let k in state.voxels) {
                const v = state.voxels[k];
                if(v.userData.ignited) {
                    v.userData.timer--; v.children[0].material.emissive = (v.userData.timer%4<2)?new THREE.Color(0xffffff):new THREE.Color(0x000000);
                    v.scale.setScalar(1+Math.random()*0.1);
                    if(v.userData.timer<=0) {
                        AudioSys.fx.explode(v.position); flashScreen(); shakeCamera(1.5);
                        spawnParticles(v.position, 0xffaa00, 30);
                        Object.keys(state.voxels).forEach(key=>{
                             const v2=state.voxels[key];
                             if(v2.position.distanceTo(v.position)<4) { delete state.voxels[key]; scene.remove(v2); spawnParticles(v2.position, v2.children[0].material.color, 4); }
                        });
                    }
                }
            }

            // Meteors
            for(let i=state.meteors.length-1; i>=0; i--) {
                const m = state.meteors[i];
                m.pos.add(new THREE.Vector3().subVectors(m.target, m.pos).normalize().multiplyScalar(0.7));
                m.mesh.position.copy(m.pos); m.mesh.rotation.x+=0.1;
                spawnParticles(m.pos, 0x550000, 1);
                if(m.pos.distanceTo(m.target)<1) {
                    AudioSys.fx.explode(m.target); flashScreen(); shakeCamera(3.0); spawnParticles(m.target, 0xff4400, 50);
                    scene.remove(m.mesh); state.meteors.splice(i,1);
                    Object.keys(state.voxels).forEach(k=>{ if(state.voxels[k].position.distanceTo(m.target)<5) { delete state.voxels[k]; scene.remove(state.voxels[k]); } });
                }
            }

            for(let i=particles.length-1; i>=0; i--) {
                const p=particles[i]; p.vel.y-=0.02; p.mesh.position.add(p.vel);
                const py = Math.round(p.mesh.position.y);
                if(py<-5 || state.voxels[`${Math.round(p.mesh.position.x)},${py},${Math.round(p.mesh.position.z)}`]) {
                    p.vel.y *= -0.5; p.vel.x*=0.8; p.vel.z*=0.8;
                }
                p.life--; if(p.life<=0){scene.remove(p.mesh); particles.splice(i,1);}
            }

            if(shake>0) { camera.position.addScalar((Math.random()-0.5)*shake); shake*=0.9; if(shake<0.01) shake=0; }
            const hrs = Math.floor(t*24); const min = Math.floor((t*24-hrs)*60);
            document.getElementById('time-display').innerText = `${hrs%12||12}:${min.toString().padStart(2,'0')} ${hrs>=12?'PM':'AM'}`;

            if(state.mode === 'orbit') orbitCtrl.update();
            composer.render();
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
